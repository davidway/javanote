[toc]

# 重复提交表单的解决方案--java语言描述

本文的内容参考了文章有

[JavaWeb学习总结(十三)——使用Session防止表单重复提交](https://www.cnblogs.com/xdp-gacl/p/3859416.html)

[AOP防止表单重复提交](https://zhuanlan.zhihu.com/p/80329417)

[每个表单重复提交方案的优缺点](https://blog.csdn.net/qq_36662478/article/details/88657268)





## 1 场景是什么?

### 1.1.必要的环境搭建



我们先不讨论分布式，先讨论这三个场景

IDEA新建一个 maven -webapp项目

在src/main里新建一个java目录

src/main/java

![image-20200414115710686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414115710686.png)



以下是demo

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <name>javanote</name>
  <groupId>com.mynote</groupId>
  <artifactId>javanote</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>
  <dependencies>
    <!-- Servlet -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <!-- JSP -->
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.2</version>
      <scope>provided</scope>
    </dependency>
    <!-- JSTL -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
      <scope>runtime</scope>
    </dependency>

    <!--slf4j-->
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.7</version>
    </dependency>

    <!--mysql-->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.33</version>
      <scope>runtime</scope>
    </dependency>

    <!--Apache commons lang-->
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.3.2</version>

    </dependency>
    <!--Apache commons collections-->
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-collections4</artifactId>
      <version>4.0</version>
    </dependency>


    <!--Junit-->
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-dbcp2</artifactId>
      <version>2.0.1</version>

    </dependency>

    <!--Junit-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>

    <!-- https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils -->
    <dependency>
      <groupId>commons-dbutils</groupId>
      <artifactId>commons-dbutils</artifactId>
      <version>1.6</version>
    </dependency>

  </dependencies>
  <build>
    <plugins>
      <!-- Compile -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.3</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
        </configuration>
      </plugin>
      <!-- Test -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>2.18.1</version>
        <configuration>
          <skipTests>true</skipTests>
        </configuration>
      </plugin>
      <!-- Tomcat -->
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.2</version>
        <configuration>
          <path>/${project.artifactId}</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```



servlet

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

  <!-- 基本配置 -->
  <servlet>
    <servlet-name>formServlet</servlet-name>
    <servlet-class>DoFormServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>formServlet</servlet-name>
    <url-pattern>/servlet/DoFormServlet</url-pattern>
  </servlet-mapping>


  <welcome-file-list>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
  </welcome-file-list>
</web-app>
```



index.jsp

```jsp
<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<!DOCTYPE HTML>
<html>
  <head>
    <title>Form表单</title>
  </head>
  
  <body>
      <form action="${pageContext.request.contextPath}/servlet/DoFormServlet" method="post">
        用户名：<input type="text" name="username">
        <input type="submit" value="提交" id="submit">
    </form>
  </body>
</html>
```



```java

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class DoFormServlet extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        //客户端是以UTF-8编码传输数据到服务器端的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码
        request.setCharacterEncoding("UTF-8");
        String userName = request.getParameter("username");
        try {
            //让当前的线程睡眠3秒钟，模拟网络延迟而导致表单重复提交的现象
            Thread.sleep(3*1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("向数据库中插入数据："+userName);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
```

#### 试着运行一下看看有没有部署错误



edit->configurations-> 选择 add +maven

Command line上输入tomcat7:run



![image-20200414120203147](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414120203147.png)



输入表单数据，出现

![image-20200414120314336](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200414120314336.png)

### 1.2 场景复现

#### 1.2.1 单机场景下



+ 场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交

> 原理：因为网络缓慢，用户当前页面没有跳转，导致用户多点击了一次按钮，触发了同一个GET/POST请求

+ 场景二：表单提交后用户点击【刷新】按钮导致表单重复提交

> 原理：刷新有同样的效果也是一样，form提交表单后，如果没有处理完整/处理中，当前的状态是在请求form表单的action，所以再刷新会重复该请求。

+ 场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交

>这个是换了个逆向的思路，得到了结果，后退，然后再提交

注意：这三个场景的原理都是：不停的同样的URL 不停的点击，触发请求。





#### 1.2 分布式场景下

+ 场景和单机一样，但是后端的实现方案不一样（因为机器是多台的。），我们稍后会讨论一下两个的实现方案的区别。



## 2.解决方案

我们现在已经知道我们要解决的问题是如何防止用户提交相同的URL与会产生相同URL的场景。

那么我们可以有什么解决方案呢？我个人认为要尽可能的拿到所有的解决方案，需要从运行流程涉及到多少组件的输入输出，就可能有多少种解决方案。

```sequence
前端->服务器: 封装参数
服务器->后端:解析get/post,调用代码
后端->数据库: 封装sql请求,发送给后端

数据库-->后端:略
后端-->服务器:略
服务器-->前端:略

```

我们可以再前端get和post请求到服务器之前，就防止表单提交，常见的有

+ javascript防止表单提交

```html
<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<!DOCTYPE HTML>
<html>
  <head>
    <title>Form表单</title>
        <script type="text/javascript">
        var isCommitted = false;//表单是否已经提交标识，默认为false
        function dosubmit(){
            if(isCommitted==false){
                isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true
                return true;//返回true让表单正常提交
            }else{
                return false;//返回false那么表单将不提交
            }
        }
    </script>
  </head>
  
  <body>
      <form action="${pageContext.request.contextPath}/servlet/DoFormServlet" onsubmit="return dosubmit()" method="post">
        用户名：<input type="text" name="username">
        <input type="submit" value="提交" id="submit">
    </form>
  </body>
</html>
```

优点：

- 简单，方便

缺点：

- 如果客户端禁用JS，这种方法就会失效
- 用户通过刷新页面方式，或使用postman等工具绕过前段页面仍能重复提交表单



+ 从后端返回到前端时，从定向

**Post-Redirect-Get (PRG)**模式。在表单提交后，你去执行一个用户重定向，跳转到提交成功的信息。这能避免用户按F5导致的重复提交。简言之就是不要让表单封装的参数url停留在当前页面中，因为如果停留在当前页面，按F5会产生一样的请求。

```java
public void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException,IOException{
　 response.setContentType("text/html; charset=utf-8");
　 response.sendRedirect("/success.jsp");
}

```

forward方法

```java
public void doPost(HttpServletRequest request, HttpServletResponse response) 
throws ServletException,IOException{
　 response.setContentType("text/html; charset=utf-8");
　 ServletContext sc = getServletContext();
　 sc.getRequestDispatcher("/success.jsp").forward(request, response);
}

```



+ 从数据库方面想解决方案

常见的有在数据库加唯一性约束sql

```sql
alter table tableName_xxx add unique key uniq_xxx(field1, field2)
```

service及时捕捉插入数据异常：

```java
try {
	xxxMapper.insert(user);
} catch (DuplicateKeyException e) {
	logger.error("user already exist");
}
```





## 4. 最适用的解决方案



## 5.解决问题





